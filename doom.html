<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Doom-ish Raycaster (fixed)</title>
<style>
  html,body { height:100%; margin:0; background:#000; }
  #gameCanvas { display:block; margin:0 auto; background:#333; }
  #hud { position:fixed; left:12px; top:12px; color:#fff; font-family:monospace; z-index:5; }
  #hint { position:fixed; right:12px; top:12px; color:#ddd; font-family:monospace; z-index:5; }
</style>
</head>
<body>
<div id="hud">Health: <span id="hp">100</span></div>
<div id="hint">WASD = move · ← → = turn · Click = shoot</div>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<script>
/* ----- Configuration ----- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hpEl = document.getElementById('hp');

const MAP = [
  [1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,1,1,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1]
];
const ROWS = MAP.length;
const COLS = MAP[0].length;
const TILE = 64;
const WORLD_W = COLS * TILE;
const WORLD_H = ROWS * TILE;

const FOV = Math.PI / 3; // 60°
const NUM_RAYS = canvas.width / 2; // each ray 2px wide
const RAY_STEP = 2; // step size for ray marching
const MAX_DEPTH = 1000;

const player = {
  x: TILE * 1.5,
  y: TILE * 1.5,
  angle: 0,
  speed: 2.2,
  radius: 10,
  health: 100,
  bullets: []
};

const enemies = [
  { x: TILE * 7 + 20, y: TILE * 2 + 20, speed: 0.6, radius: 12, alive:true }
];

const keys = {};

/* ----- Helpers ----- */
function inBounds(x,y){
  return x >= 0 && x < WORLD_W && y >= 0 && y < WORLD_H;
}
function mapCellAtXY(x,y){
  if(!inBounds(x,y)) return 1; // out-of-bounds treated as wall
  const col = Math.floor(x / TILE);
  const row = Math.floor(y / TILE);
  return MAP[row][col];
}
function isWallAtXY(x,y){
  return mapCellAtXY(x,y) === 1;
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* ----- Controls ----- */
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

/* Shoot forwards (click) */
canvas.addEventListener('click', () => {
  // create bullet in world coords heading in player's direction
  const speed = 6;
  player.bullets.push({
    x: player.x + Math.cos(player.angle) * (player.radius + 4),
    y: player.y + Math.sin(player.angle) * (player.radius + 4),
    dx: Math.cos(player.angle) * speed,
    dy: Math.sin(player.angle) * speed,
    life: 120
  });
});

/* ----- Raycasting ----- */
function castRays(){
  const rays = [];
  const startAngle = player.angle - FOV/2;
  for(let i=0;i<NUM_RAYS;i++){
    const rayAngle = startAngle + (i / NUM_RAYS) * FOV;
    // normalize
    let sin = Math.sin(rayAngle);
    let cos = Math.cos(rayAngle);
    let distance = 0;
    let hit = false;
    let hitX = 0, hitY = 0;
    while(!hit && distance < MAX_DEPTH){
      distance += RAY_STEP;
      const testX = player.x + cos * distance;
      const testY = player.y + sin * distance;
      if(!inBounds(testX, testY)) { hit = true; hitX = testX; hitY = testY; break; }
      if(mapCellAtXY(testX, testY) === 1){
        hit = true;
        hitX = testX; hitY = testY;
        break;
      }
    }
    rays.push({distance, angle: rayAngle, hitX, hitY});
  }
  return rays;
}

/* ----- Movement with collision ----- */
function tryMove(newX, newY){
  // check center cell
  if(isWallAtXY(newX, newY)) return false;
  // small radius check (simple)
  const corners = [
    {x:newX - player.radius, y:newY - player.radius},
    {x:newX + player.radius, y:newY - player.radius},
    {x:newX - player.radius, y:newY + player.radius},
    {x:newX + player.radius, y:newY + player.radius}
  ];
  for(const c of corners){
    if(isWallAtXY(c.x, c.y)) return false;
  }
  player.x = newX; player.y = newY;
  return true;
}

/* ----- Updates ----- */
function updatePlayer(){
  let vx = 0, vy = 0;
  if(keys['w']) { vx += Math.cos(player.angle) * player.speed; vy += Math.sin(player.angle) * player.speed; }
  if(keys['s']) { vx -= Math.cos(player.angle) * player.speed; vy -= Math.sin(player.angle) * player.speed; }
  if(keys['a']) { vx += Math.cos(player.angle - Math.PI/2) * player.speed; vy += Math.sin(player.angle - Math.PI/2) * player.speed; }
  if(keys['d']) { vx += Math.cos(player.angle + Math.PI/2) * player.speed; vy += Math.sin(player.angle + Math.PI/2) * player.speed; }
  const nextX = player.x + vx;
  const nextY = player.y + vy;
  tryMove(nextX, nextY);
  if(keys['arrowleft']) player.angle -= 0.04;
  if(keys['arrowright']) player.angle += 0.04;
}

function updateBullets(){
  for(let i = player.bullets.length - 1; i >= 0; i--){
    const b = player.bullets[i];
    b.x += b.dx; b.y += b.dy; b.life--;
    // remove if hit wall or out of world or expired
    if(!inBounds(b.x, b.y) || mapCellAtXY(b.x,b.y) === 1 || b.life <= 0){
      player.bullets.splice(i,1);
      continue;
    }
    // check collision with enemies
    for(let j = 0; j < enemies.length; j++){
      const e = enemies[j];
      if(!e.alive) continue;
      const dist = Math.hypot(b.x - e.x, b.y - e.y);
      if(dist < e.radius + 4){
        // enemy hit
        e.alive = false;
        player.bullets.splice(i,1);
        break;
      }
    }
  }
}

function updateEnemies(){
  enemies.forEach(e => {
    if(!e.alive) return;
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy);
    if(dist > 0){
      const nx = e.x + (dx / dist) * e.speed;
      const ny = e.y + (dy / dist) * e.speed;
      // avoid walking through walls (simple check)
      if(!isWallAtXY(nx, ny)){
        e.x = nx; e.y = ny;
      }
    }
    // damage player when close
    if(dist < player.radius + e.radius + 2){
      player.health -= 0.3;
      player.health = clamp(player.health, 0, 100);
      hpEl.textContent = Math.floor(player.health);
    }
  });
}

/* ----- Drawing ----- */
function drawScene(){
  // sky and floor
  ctx.fillStyle = '#666';
  ctx.fillRect(0,0,canvas.width, canvas.height/2); // sky/ceiling
  ctx.fillStyle = '#111';
  ctx.fillRect(0,canvas.height/2,canvas.width, canvas.height/2); // floor

  // walls (raycast)
  const rays = castRays();
  const rayWidth = canvas.width / rays.length;
  for(let i=0;i<rays.length;i++){
    const r = rays[i];
    const delta = r.angle - player.angle;
    // correct fish-eye
    const corrected = r.distance * Math.cos(delta);
    const h = (TILE * canvas.height) / (corrected || 0.0001);
    const shade = clamp(255 - corrected * 0.6, 30, 255);
    ctx.fillStyle = `rgb(${Math.floor(shade)},0,0)`; // doom-ish red walls
    ctx.fillRect(i * rayWidth, (canvas.height/2) - h/2, Math.ceil(rayWidth), h);
  }

  // draw enemies as vertical sprites if within FOV
  enemies.forEach(e => {
    if(!e.alive) return;
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    const dist = Math.hypot(dx, dy);
    if(dist < 10) return;
    let angleToEnemy = Math.atan2(dy, dx);
    // normalize difference to [-PI,PI]
    let diff = angleToEnemy - player.angle;
    while(diff > Math.PI) diff -= 2*Math.PI;
    while(diff < -Math.PI) diff += 2*Math.PI;
    if(Math.abs(diff) > FOV/2) return; // not on screen
    const spriteHeight = (TILE * canvas.height) / dist;
    const screenX = (0.5 + Math.tan(diff) / Math.tan(FOV/2) * 0.5) * canvas.width;
    // simple occlusion by distance: if spriteHeight huge or screenX NaN skip
    if(!isFinite(screenX)) return;
    ctx.fillStyle = 'green';
    ctx.fillRect(screenX - 10, (canvas.height/2) - spriteHeight/2, 20, spriteHeight);
  });

  // draw bullets (world coords -> mini representation)
  ctx.fillStyle = 'yellow';
  player.bullets.forEach(b => {
    // show bullet as small dot in center area for quick visual
    // we also draw a tiny 2px indicator on HUD area so player sees bullets are traveling
    ctx.fillRect( (b.x - player.x) + canvas.width/2 - 1, (b.y - player.y) + canvas.height/2 - 1, 2, 2);
  });

  // center crosshair
  ctx.strokeStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(canvas.width/2 - 8, canvas.height/2);
  ctx.lineTo(canvas.width/2 + 8, canvas.height/2);
  ctx.moveTo(canvas.width/2, canvas.height/2 - 8);
  ctx.lineTo(canvas.width/2, canvas.height/2 + 8);
  ctx.stroke();
}

/* ----- Game Loop ----- */
function gameLoop(){
  updatePlayer();
  updateBullets();
  updateEnemies();
  drawScene();
  requestAnimationFrame(gameLoop);
}

/* ----- Start ----- */
hpEl.textContent = Math.floor(player.health);
gameLoop();
</script>
</body>
</html>
