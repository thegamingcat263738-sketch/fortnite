<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VSRG — Finalized</title>
<style>
:root{
  --bg:#0b0f14; --panel:#0f1720; --accent:#0fb6ff; --muted:#9fb6c9;
  --card:#121821; --white:#e6f0f6; --shadow: 0 8px 30px rgba(0,0,0,0.6);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--white);font-family:Inter,system-ui,Arial;overflow:hidden}

/* Title */
#titleScreen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:linear-gradient(180deg,#04101a,#071018);z-index:200}
.titleBtn{padding:14px 28px;font-size:18px;border-radius:12px;background:var(--accent);color:#022029;border:none;cursor:pointer;margin:8px;font-weight:800;box-shadow:var(--shadow)}
.titleBtn:hover{transform:translateY(-4px);filter:brightness(.96)}

/* Right-side song select */
#songSelect{position:fixed;right:0;top:0;width:360px;height:100%;background:linear-gradient(180deg,rgba(5,10,15,0.96),rgba(8,12,20,0.98));padding:18px;box-sizing:border-box;border-left:1px solid rgba(255,255,255,0.03);overflow-y:auto;z-index:50;display:none}
#songSelectHeader{display:flex;align-items:center;gap:12px;margin-bottom:14px}
#songThumb{width:84px;height:84px;border-radius:8px;background:url('Boom.png') center/cover no-repeat;box-shadow:var(--shadow);border:1px solid rgba(255,255,255,0.04)}
.songGrid{display:flex;flex-direction:column;gap:10px}
.songCard{display:flex;justify-content:space-between;align-items:center;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));border-radius:10px;cursor:pointer;transition:transform .12s,box-shadow .12s;border:1px solid rgba(255,255,255,0.03)}
.songCard:hover{transform:translateY(-6px);box-shadow:0 12px 30px rgba(0,0,0,0.6)}
.songTitle{font-weight:700;font-size:15px}
.songMeta{color:var(--muted);font-size:13px}
.playBtn{padding:8px 10px;background:var(--accent);color:#022029;border-radius:8px;border:none;font-weight:800;cursor:pointer}
.playBtn:hover{filter:brightness(.96)}

/* HUD left */
#hud{position:fixed;left:16px;top:16px;width:260px;background:var(--panel);border-radius:12px;padding:12px;box-shadow:var(--shadow);border:1px solid rgba(255,255,255,0.03);z-index:20;display:none}
.statRow{display:flex;justify-content:space-between;color:var(--muted);margin-top:8px;font-size:14px}

/* Controls */
#controlsBar{position:fixed;right:380px;top:16px;width:300px;background:var(--panel);border-radius:12px;padding:12px;box-shadow:var(--shadow);border:1px solid rgba(255,255,255,0.03);z-index:20;display:none}
#controlsBar .label{color:var(--muted);font-size:13px;margin-bottom:8px}

/* Stage */
#stageWrap{position:fixed;left:50%;top:40px;transform:translateX(-50%);width:640px;height:880px;display:flex;align-items:center;justify-content:center;z-index:10;pointer-events:none;display:none}
#gameCanvas{pointer-events:auto;width:560px;height:800px;background:linear-gradient(180deg,#061018,#0b1220);border-radius:12px;box-shadow:0 18px 40px rgba(0,0,0,0.7);border:3px solid rgba(255,255,255,0.04)}

/* Bottom UI */
#bottomUI{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:20;display:none;gap:12px}
.bigBtn{pointer-events:auto;padding:10px 16px;background:var(--card);color:var(--white);border-radius:10px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 20px rgba(0,0,0,0.6);cursor:pointer;font-weight:600}
.bigBtn:hover{transform:translateY(-2px)}

/* Pause overlay & summary */
#pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:60}
#pauseBox{background:var(--panel);padding:20px;border-radius:12px;box-shadow:var(--shadow);text-align:center}

/* Summary modal */
.summaryModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:linear-gradient(180deg,#0e1419,#071018);padding:22px;border-radius:12px;box-shadow:0 18px 40px rgba(0,0,0,0.6);color:#fff;z-index:120}

/* responsive */
@media (max-width:1000px){#stageWrap{top:20px}#songSelect{width:320px}#controlsBar{right:340px}}
</style>
</head>
<body>

<!-- Title -->
<div id="titleScreen">
  <h1 style="font-size:46px;margin:0;color:var(--white)">VSRG</h1>
  <p style="color:var(--muted);margin:8px 0 20px 0">Polished rhythm prototype — close lanes, big notes</p>
  <div>
    <button class="titleBtn" id="startBtn">Start</button>
    <button class="titleBtn" id="creditsBtn">Credits</button>
  </div>
  <div style="margin-top:18px;color:var(--muted)">Put <strong>Boom.png</strong> in the same folder for the song thumbnail.</div>
</div>

<!-- Song select (right) -->
<div id="songSelect" aria-hidden="true">
  <div id="songSelectHeader">
    <div id="songThumb" title="Boom.png thumbnail"></div>
    <div>
      <h2 style="margin:0">Song Select</h2>
      <div style="color:var(--muted);font-size:13px">Choose a chart — double-click or Play</div>
    </div>
  </div>
  <div class="songGrid" id="songGrid"></div>
</div>

<!-- HUD -->
<div id="hud" aria-hidden="true">
  <h3 id="nowTitle" style="margin:0 0 8px 0">No song</h3>
  <div class="statRow"><span>Score</span><strong id="score">0</strong></div>
  <div class="statRow"><span>Combo</span><strong id="combo">0</strong></div>
  <div class="statRow"><span>Misses</span><strong id="misses">0</strong></div>
</div>

<!-- Controls -->
<div id="controlsBar" aria-hidden="true">
  <div class="label">Speed</div>
  <input id="speedSlider" type="range" min="8" max="28" step="1" value="14" />
  <div style="margin-top:8px"><strong id="speedDisplay">14</strong></div>
  <div style="margin-top:8px;color:var(--muted)">Keys: Z X N M • Pause: T</div>
</div>

<!-- Stage -->
<div id="stageWrap" aria-hidden="true">
  <canvas id="gameCanvas" width="560" height="800" tabindex="0"></canvas>
</div>

<!-- Bottom UI -->
<div id="bottomUI" aria-hidden="true">
  <button class="bigBtn" id="pauseBtn">Pause (T)</button>
  <button class="bigBtn" id="restartBtn">Restart</button>
  <button class="bigBtn" id="backBtn">Song Select</button>
</div>

<!-- Pause overlay -->
<div id="pauseOverlay">
  <div id="pauseBox">
    <h2>Paused</h2>
    <div style="margin-top:14px">
      <button class="bigBtn" id="resumeBtn">Resume</button>
      <button class="bigBtn" id="pauseRestart">Restart</button>
      <button class="bigBtn" id="pauseBack">Song Select</button>
    </div>
  </div>
</div>

<script>
/* =============================
   VSRG Finalized — Single File
   ============================= */

/* Core DOM */
const titleScreen = document.getElementById('titleScreen');
const startBtn = document.getElementById('startBtn');
const creditsBtn = document.getElementById('creditsBtn');

const songSelect = document.getElementById('songSelect');
const songGrid = document.getElementById('songGrid');
const songThumb = document.getElementById('songThumb');

const hud = document.getElementById('hud');
const nowTitle = document.getElementById('nowTitle');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const missesEl = document.getElementById('misses');

const controlsBar = document.getElementById('controlsBar');
const speedSlider = document.getElementById('speedSlider');
const speedDisplay = document.getElementById('speedDisplay');

const stageWrap = document.getElementById('stageWrap');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const bottomUI = document.getElementById('bottomUI');
const pauseOverlay = document.getElementById('pauseOverlay');

const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');
const backBtn = document.getElementById('backBtn');
const resumeBtn = document.getElementById('resumeBtn');
const pauseRestart = document.getElementById('pauseRestart');
const pauseBack = document.getElementById('pauseBack');

/* Canvas dims */
const canvasW = canvas.width;
const canvasH = canvas.height;

/* Playfield */
const columns = 4;
const playfieldWidth = 400;
const playfieldX = (canvasW - playfieldWidth) / 2;
const columnWidth = playfieldWidth / columns;
const laneCenters = new Array(columns).fill(0).map((_,i) => playfieldX + i*columnWidth + columnWidth/2);

/* Notes appearance & hit */
let hitY = canvasH - 300;        // raised for reaction time
let noteRadiusX = 68;            // wider
let noteRadiusY = 48;            // taller
let hitWindow = 110;             // lenient

/* Game state */
let notes = [];                  // array of {lane,y,hit,judgment,hitTime}
let score = 0, combo = 0, misses = 0;
let judgments = {Marvellous:0, Perfect:0, Good:0, Bad:0};
let baseSpeed = parseInt(speedSlider.value,10);
let gameRunning = false;
let paused = false;
let activeSong = null;
let difficulty = 'Normal';
let animId = null;

/* Song list (placeholder) */
const songs = [
  {id:'s1', title:'Random Beat 1', artist:'Unknown', difficulty:'Easy'},
  {id:'s2', title:'Random Beat 2', artist:'Unknown', difficulty:'Normal'},
  {id:'s3', title:'Random Beat 3', artist:'Unknown', difficulty:'Hard'},
  {id:'s4', title:'Random Beat 4', artist:'Unknown', difficulty:'Experienced'}
];

/* -------------------------
   UI: title, song cards
   ------------------------- */
startBtn.addEventListener('click',()=>{
  titleScreen.style.display='none';
  showSongSelect();
});
creditsBtn.addEventListener('click',()=>alert('VSRG prototype — built with ❤️\nControls: Z X N M to hit, T to pause.'));

function buildSongCards(){
  songGrid.innerHTML = '';
  songs.forEach(s=>{
    const card = document.createElement('div');
    card.className='songCard';
    card.innerHTML = `
      <div style="display:flex;flex-direction:column">
        <div class="songTitle">${s.title}</div>
        <div class="songMeta">${s.artist} • default ${s.difficulty}</div>
      </div>
      <div>
        <button class="playBtn" data-id="${s.id}">Play</button>
      </div>`;
    songGrid.appendChild(card);
    card.querySelector('.playBtn').addEventListener('click',()=>openSong(s));
    card.addEventListener('dblclick',()=>openSong(s));
  });
}

/* Show/hide panels */
function showSongSelect(){
  songSelect.style.display = 'block';
  hud.style.display = 'none';
  controlsBar.style.display = 'none';
  stageWrap.style.display = 'none';
  bottomUI.style.display = 'none';
}
function showGameUI(){
  songSelect.style.display = 'none';
  hud.style.display = 'block';
  controlsBar.style.display = 'block';
  stageWrap.style.display = 'flex';
  bottomUI.style.display = 'flex';
  pauseOverlay.style.display = 'none';
  canvas.focus();
}

/* Open song -> difficulty prompt (quick) */
function openSong(song){
  activeSong = song;
  nowTitle.textContent = `${song.title} — ${song.artist}`;
  const diff = prompt('Choose difficulty: Easy / Normal / Hard / Experienced', song.difficulty) || song.difficulty;
  difficulty = diff;
  showGameUI();
  startGame();
}

/* -------------------------
   Chart generator (improved)
   -------------------------
   Approach:
   - Build a timeline of "rows" (index i)
   - For each row decide a pattern based on difficulty:
       single note, stream (single per row but consecutive rows), jump (2-lane simultaneous),
       handstream (3-lane simult), chord (4-lane), jack (same lane quick repeats)
   - Ensure lanes chosen per row don't conflict with other simultaneous notes
   - Convert rows to initial Y positions using spacing
*/
function generateChart(diff){
  notes = [];
  let rows;
  let spacing;
  let patternWeights;
  if(diff.toLowerCase() === 'easy'){
    rows = 48; spacing = 160;
    patternWeights = {single:0.8, stream:0.12, jump:0.05, hand:0.02, jack:0.01, chord:0.0};
  } else if(diff.toLowerCase() === 'normal'){
    rows = 84; spacing = 140;
    patternWeights = {single:0.6, stream:0.2, jump:0.12, hand:0.04, jack:0.03, chord:0.01};
  } else if(diff.toLowerCase() === 'hard'){
    rows = 130; spacing = 120;
    patternWeights = {single:0.35, stream:0.35, jump:0.15, hand:0.08, jack:0.05, chord:0.02};
  } else { // experienced
    rows = 200; spacing = 100;
    patternWeights = {single:0.2, stream:0.45, jump:0.18, hand:0.1, jack:0.05, chord:0.02};
  }

  // helper: pick weighted
  function pickWeighted(map){
    const entries = Object.entries(map);
    const total = entries.reduce((s,[_k,v])=>s+v,0);
    let r = Math.random()*total;
    for(const [k,v] of entries){
      if(r < v) return k;
      r -= v;
    }
    return entries[0][0];
  }

  // To avoid stacking: track lanes occupied at same row index when simultaneous
  for(let i=0;i<rows;i++){
    const pattern = pickWeighted(patternWeights);

    // for jacks, we will insert a short cluster of repeated notes on same lane across small offset rows
    if(pattern === 'jack'){
      const lane = Math.floor(Math.random()*columns);
      // put 3 quick repeats across next 3 rows with smaller spacing
      notes.push({lane, y: -i*spacing - 220, hit:false});
      notes.push({lane, y: -(i+0.3)*spacing - 220, hit:false});
      notes.push({lane, y: -(i+0.6)*spacing - 220, hit:false});
      i += 0; // still counted as base row (spacing handles timing)
      continue;
    }

    if(pattern === 'single'){
      const lane = Math.floor(Math.random()*columns);
      notes.push({lane, y: -i*spacing - 220, hit:false});
      continue;
    }

    if(pattern === 'stream'){
      // create a short stream: 3-6 rows starting at i
      const len = 3 + Math.floor(Math.random()*4); // 3..6
      let prevLane = Math.floor(Math.random()*columns);
      for(let k=0;k<len;k++){
        // pick a lane different from prevLane (simple stream)
        let lane = (prevLane + (Math.random() < 0.6 ? 1 : (Math.random()<0.5?-1:2))) % columns;
        lane = (lane + columns) % columns;
        notes.push({lane, y: -(i+k)*spacing - 220, hit:false});
        prevLane = lane;
      }
      i += len-1; // advance rows
      continue;
    }

    if(pattern === 'jump'){
      // pick 2 distinct lanes (prefer non-adjacent occasionally)
      let a = Math.floor(Math.random()*columns);
      let b = a;
      while(b === a) b = Math.floor(Math.random()*columns);
      // create a simultaneous jump at this row
      notes.push({lane:a, y: -i*spacing - 220, hit:false});
      notes.push({lane:b, y: -i*spacing - 220, hit:false});
      // maybe add a short follow stream after
      if(Math.random() < 0.5){
        const followLen = 2 + Math.floor(Math.random()*3);
        let prev = Math.random() < 0.5 ? a : b;
        for(let k=1;k<=followLen;k++){
          prev = (prev + (Math.random()<0.5?1:-1) + columns) % columns;
          notes.push({lane: prev, y: -(i+k)*spacing - 220, hit:false});
        }
        i += followLen;
      }
      continue;
    }

    if(pattern === 'hand'){
      // choose 3 distinct lanes
      const all = [0,1,2,3].sort(()=>Math.random()-0.5);
      notes.push({lane:all[0], y: -i*spacing - 220, hit:false});
      notes.push({lane:all[1], y: -i*spacing - 220, hit:false});
      notes.push({lane:all[2], y: -i*spacing - 220, hit:false});
      continue;
    }

    if(pattern === 'chord'){
      // 4-lane chord
      for(let l=0;l<columns;l++) notes.push({lane:l, y: -i*spacing - 220, hit:false});
      continue;
    }
  }

  // final: sort notes by starting y ascending (already roughly in that order)
  notes.sort((a,b) => a.y - b.y);
}

/* -------------------------
   Game mechanics
   ------------------------- */
function startGame(){
  score = 0; combo = 0; misses = 0;
  judgments = {Marvellous:0, Perfect:0, Good:0, Bad:0};
  baseSpeed = parseInt(speedSlider.value,10);
  speedDisplay.textContent = baseSpeed;
  generateChart(difficulty);
  gameRunning = true;
  paused = false;
  cancelAnimationFrame(animId);
  animId = requestAnimationFrame(loop);
  updateHUD();
}
function stopGame(){
  gameRunning = false;
  paused = false;
  cancelAnimationFrame(animId);
}
function setPaused(v){
  paused = !!v;
  pauseOverlay.style.display = paused ? 'flex' : 'none';
  if(!paused) canvas.focus();
}

/* input */
const keyMap = {'z':0,'x':1,'n':2,'m':3};
window.addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();
  if(k === 't'){ if(gameRunning) setPaused(!paused); return; }
  if(!gameRunning || paused) return;
  if(k in keyMap) tryHit(keyMap[k]);
});

/* Hit detection — vertical distance, lenient window */
function tryHit(laneIndex){
  const candidates = notes.filter(n => !n.hit && n.lane === laneIndex);
  if(candidates.length === 0) return;
  let nearest = null, bestD = Infinity;
  for(const n of candidates){
    const d = Math.abs(n.y - hitY);
    if(d < bestD){ bestD = d; nearest = n; }
  }
  if(nearest && bestD <= hitWindow){
    nearest.hit = true;
    nearest.hitTime = performance.now();
    let judgment;
    if(bestD < 24){ judgment = 'Marvellous'; score += 1200; combo++; judgments.Marvellous++; }
    else if(bestD < 48){ judgment = 'Perfect'; score += 700; combo++; judgments.Perfect++; }
    else if(bestD < 80){ judgment = 'Good'; score += 300; combo = 0; judgments.Good++; }
    else { judgment = 'Bad'; combo = 0; misses++; judgments.Bad++; }
    nearest.judgment = judgment;
    spawnHitEffect(laneIndex);
    updateHUD();
  } else {
    // ghost tap allowed: no penalty
  }
}

/* Floating hit visuals (simple) */
const hitParticles = [];
function spawnHitEffect(laneIndex){
  // small particles and quick popup handled as judgment text (rendered from notes)
  for(let i=0;i<8;i++){
    hitParticles.push({
      x: laneCenters[laneIndex] + (Math.random()-0.5)*30,
      y: hitY + (Math.random()-0.5)*10,
      vx: (Math.random()-0.5)*2,
      vy: - (1 + Math.random()*2),
      life: 600 + Math.random()*400
    });
  }
}

/* HUD */
function updateHUD(){
  scoreEl.textContent = score;
  comboEl.textContent = combo;
  missesEl.textContent = misses;
}

/* main loop */
function loop(){
  animId = requestAnimationFrame(loop);
  ctx.clearRect(0,0,canvasW,canvasH);

  // playfield area
  ctx.fillStyle = '#081219';
  ctx.fillRect(playfieldX - 8, 0, playfieldWidth + 16, canvasH);

  // lane backgrounds
  for(let i=0;i<columns;i++){
    ctx.fillStyle = '#071014';
    ctx.fillRect(playfieldX + i*columnWidth, 0, columnWidth, canvasH);
  }

  // draw hit circles (barline)
  for(let i=0;i<columns;i++){
    ctx.beginPath();
    ctx.ellipse(laneCenters[i], hitY, noteRadiusX, noteRadiusY, 0, 0, Math.PI*2);
    ctx.fillStyle = '#61666b';
    ctx.fill();
  }

  // update note positions (only when running + not paused)
  if(gameRunning && !paused){
    for(const n of notes){ if(!n.hit) n.y += baseSpeed; }
  }

  // draw notes (as wide ellipses)
  for(const n of notes){
    if(!n.hit){
      ctx.beginPath();
      ctx.ellipse(laneCenters[n.lane], n.y, noteRadiusX, noteRadiusY, 0, 0, Math.PI*2);
      ctx.fillStyle = '#c9ced2';
      ctx.fill();
    }
  }

  // draw hit judgments and fade
  const now = performance.now();
  for(const n of notes){
    if(n.hit && n.judgment && now - n.hitTime < 1000){
      const alpha = 1 - ((now - n.hitTime)/1000);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#fff';
      ctx.font = '20px Inter, Arial';
      ctx.textAlign = 'center';
      ctx.fillText(n.judgment, laneCenters[n.lane], n.y - 90);
      ctx.globalAlpha = 1;
    }
  }

  // update and draw particles
  for(let i=hitParticles.length-1;i>=0;i--){
    const p = hitParticles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.life -= 16.6;
    ctx.globalAlpha = Math.max(0, p.life/1000);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(p.x, p.y, 3, 3);
    ctx.globalAlpha = 1;
    if(p.life <= 0) hitParticles.splice(i,1);
  }

  // mark misses (only once)
  for(const n of notes){
    if(!n.hit && n.y > hitY + hitWindow){
      n.hit = true;
      n.judgment = 'Bad';
      n.hitTime = performance.now();
      misses++; combo = 0; judgments.Bad++;
      updateHUD();
    }
  }

  // HUD overlay text (canvas top-left)
  ctx.fillStyle = '#cfeaf8';
  ctx.font = '14px Inter, Arial';
  ctx.textAlign = 'left';
  ctx.fillText('Now playing: ' + (activeSong ? activeSong.title : '—'), 14, 18);

  // finished?
  if(gameRunning && notes.every(n => n.hit)){
    gameRunning = false;
    setTimeout(()=>showSummary(), 260);
  }
}

/* show summary modal immediately */
function showSummary(){
  stopGame();
  // remove existing
  const prev = document.getElementById('summaryModal');
  if(prev) prev.remove();

  const modal = document.createElement('div');
  modal.id = 'summaryModal';
  modal.className = 'summaryModal';
  modal.innerHTML = `
    <h2>Song Complete</h2>
    <div style="margin-top:10px;text-align:left">
      <div>Score: ${score}</div>
      <div>Combo: ${combo}</div>
      <div>Misses: ${misses}</div>
      <div style="margin-top:8px">Marvellous: ${judgments.Marvellous} • Perfect: ${judgments.Perfect} • Good: ${judgments.Good} • Bad: ${judgments.Bad}</div>
    </div>
    <div style="margin-top:12px;display:flex;gap:10px;justify-content:center">
      <button class="bigBtn" id="summaryRestart">Restart</button>
      <button class="bigBtn" id="summaryBack">Song Select</button>
    </div>
  `;
  document.body.appendChild(modal);
  document.getElementById('summaryRestart').addEventListener('click', ()=>{ modal.remove(); startGame(); });
  document.getElementById('summaryBack').addEventListener('click', ()=>{ modal.remove(); showSongSelect(); });
}

/* Buttons wiring */
pauseBtn.addEventListener('click', ()=>{ if(gameRunning) setPaused(!paused); });
restartBtn.addEventListener('click', ()=> startGame());
backBtn.addEventListener('click', ()=> showSongSelect());
resumeBtn.addEventListener('click', ()=> setPaused(false));
pauseRestart.addEventListener('click', ()=>{ setPaused(false); startGame(); });
pauseBack.addEventListener('click', ()=>{ setPaused(false); showSongSelect(); });

speedSlider.addEventListener('input', e=>{ baseSpeed = parseInt(e.target.value,10); speedDisplay.textContent = baseSpeed; });

/* Initial setup */
buildSongCards();
showSongSelect();
canvas.addEventListener('click', ()=> canvas.focus());
canvas.setAttribute('tabindex','0');

</script>
</body>
</html>
